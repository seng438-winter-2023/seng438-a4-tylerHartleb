**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group \#:      |   14  |
| -------------- | --- |
| Student Names: |  Tyler   |
|                |   Jaxon  |
|                |   Nicola  |
|                |   Mary  |

# Introduction


# Analysis of 10 Mutants of the Range class 

| Mutant                                           | Analysis                                                                                                                                                             | Killed? |
| ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------- |
| 333: Changed conditional boundary                | This mutant changed the conditional boundary of (lower < upper) in the Expand method. We can kill this mutant by adding additional boundary test cases.              | No      |
| 349: Replaced return value with null             | This mutant changes the return value of the shift function with a null value. This function should be killed by ensuring we are checking for null in our test cases. | No      |
| 365: Removed call to nullNotPermitted            | This mutant removes a call to the nullNotPermitted call in the shift function. This causes the function to not throw a result if a null value is passed in.          | No      |
| 391: Replaced double addition with subtraction   | This mutant replaces the addition call in the shiftWithNoZeroCrossing function. This mutant should be killed by testing with a negative value.                       | No      |
| 388: Replaced double return value with 0.0d      | This mutant replaces the return value in shiftWithNoZeroCrossing function with 0.0d. This mutant should be killed by testing with a positive value.                  | No      |
| 105: Replaced double return value with 0.0d      | This mutant replaces the return value in getLowerBound with zero.                                                                                                    | Yes     |
| 331: Replace double multiplication with division | This mutant replaces the multiplication in expand with division. This was killed as we tested equivalence classes.                                                   | Yes     |
| 90: Negated Conditional                          | This mutant negates the lower < upper conditional in the Range constructor. It                                                                                       | Yes     |
| 144: Replaced boolean return with False          | This mutant replaces the return value in contains with false. It will have been killed by any test that expects a true value.                                        | Yes     |
| 144: Replaced boolean return with True           | This mutant replaces the return value in contains with false. It will have been killed by any test that expects a false value.                                       | Yes     |

# Report all the statistics and the mutation score for each test class

Original Coverage:

| Class         | Line Coverage | Mutation Coverage | Test Strength |
| ------------- | ------------- | ----------------- | ------------- |
| Range         | 66%           | 26%               | 40%           |
| DataUtilities | 51%           | 49%               | 100%          |

Updated Coverage:

| Class         | Line Coverage | Mutation Coverage | Test Strength |
| ------------- | ------------- | ----------------- | ------------- |
| Range         | 69%           | 47%               | 71%           |
| DataUtilities | 51%           | 49%               | 100%          |


# Analysis drawn on the effectiveness of each of the test classes

Our unit tests for DataUtilities was highly effective and killed every mutant that was covered by unit tests. There are mutations that were not covered by unit tests as we did not test all methods in the class. Our test cases for the Range class was not as effective and quite a few mutants covered by unit tests survived. Most of the surviving mutations were mutants that replaced a return value with a null or negated a conditional.

# A discussion on the effect of equivalent mutants on mutation score accuracy

Equivalent mutants cause the mutation score to be lower than it should be, and leads us to believe that the test suite is inadequate. This is why it is important, if possible, to remove equivalent mutants from the mutants being used, as less equivalent mutants will increase the accuracy of the mutation score and make the mutation score a more accurate tool in assessing the strength of a given test suite.

# A discussion of what could have been done to improve the mutation score of the test suites

To improve the mutation score we can test more boundary cases. The majority of mutants missed in the Range class were boundary cases such as null, or conditional boundary changes. From these results it is important to be cognizant of boundaries when designing unit tests especially null values and the values around conditional changes. Additionally, some of our unit tests missed mutations as we did not properly check for a null value. By fixing these errors we were able to increase our mutation coverage without needing to add additional test cases.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing

Mutation testing is important because it helps ensure the quality of the test suite. It helps us make sure that our application is passing the tests because there is no error rather than due to poor quality of the tests. The advantages to mutation testing is that it can be automated, it is systematic and there is a clear target to aim for in mutation scores. It also allows for comparison of different test suites to determine which suite is better suited for the applications. Some challenges to mutation testing is the amount of resources it requires and the issue of equivalent mutations. There are also often too many mutants in an application for it to be feasible for manual equivalent mutant detection to be done. 

# Explain your SELENIUM test case design process

To build SELENIUM test cases, we started by brainstorming what the most common functionalities of the website would be, and came up with the following 8 functions to test:

| Functions on [Amazon.ca](http://Amazon.ca) |
| ------------------------------------------ |
| Login                                      |
| Register                                   |
| Search                                     |
| Adding to cart                             |
| Create a List                              |
| Adding a shipping address                  |
| Changing the country                       |
| Editing item from cart                     |

# Explain the use of assertions and checkpoints

# How did you test each functionaity with different test data?

# Discuss advantages and disadvantages of Selenium vs. Sikulix

# How the team work/effort was divided and managed


# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the lab itself
